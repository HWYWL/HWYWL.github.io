---
title: 抽象工厂设计模式
date: 2018-10-11 10:25:36
tags: 
 - 设计模式
categories: 
 - 设计模式
keywords: "设计模式"
description: 抽象工厂设计模式。
---

## 抽象工厂（Abstract Factory）

### Intent

提供一个接口，用于创建  **相关的对象家族** 。

### Class Diagram

抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。

抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。

至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。

从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。

![](https://i.imgur.com/rHg602N.jpg)

### Implementation

```java
public class AbstractProductA {
    public void helloA(String h){
        System.out.println("HelloA " + h);
    }
}
```

```java
public class AbstractProductB {
    public void helloB(String h){
        System.out.println("HelloB " + h);
    }
}
```

```java
public class ProductA1 extends AbstractProductA {
    public void hiA1(String h){
        System.out.println("HiA1 " + h);
    }
}

```

```java
public class ProductA2 extends AbstractProductA {
    public void hiA2(String h){
        System.out.println("HiA2 " + h);
    }
}

```

```java
public class ProductB1 extends AbstractProductB {
    public void hiB1(String h){
        System.out.println("HiB1 " + h);
    }
}
```

```java
public class ProductB2 extends AbstractProductB {
    public void hiB2(String h){
        System.out.println("HiB2 " + h);
    }
}
```

```java
/**
 * 抽象类工厂
 * @author YI
 * @date 2018-10-11 11:01:28
 */
public abstract class AbstractFactory {
    abstract AbstractProductA createProductA();

    abstract AbstractProductB createProductB();
}
```

```java
/**
 * 实现工厂一
 * @author YI
 * @date 2018-10-11 11:01:28
 */
public class ConcreteFactory1 extends AbstractFactory {
    @Override
    AbstractProductA createProductA() {
        return new ProductA1();
    }

    @Override
    AbstractProductB createProductB() {
        return new ProductB1();
    }
}
```

```java
/**
 * 实现工厂二
 * @author YI
 * @date 2018-10-11 11:01:28
 */
public class ConcreteFactory2 extends AbstractFactory {
    @Override
    AbstractProductA createProductA() {
        return new ProductA2();
    }

    @Override
    AbstractProductB createProductB() {
        return new ProductB2();
    }
}
```

```java
/**
 * 通过不同的工厂获取不同的对象
 * @author YI
 * @date 2018-10-11 11:03:36
 */
public class Client {
    public static void main(String[] args) {
        AbstractFactory abstractFactory = new ConcreteFactory1();

        AbstractProductA productA = abstractFactory.createProductA();
        AbstractProductB productB = abstractFactory.createProductB();
        productA.helloA("美女");
        productB.helloB("校花");
        // do something with productA and productB
    }
}
```

### JDK

- [javax.xml.parsers.DocumentBuilderFactory](http://docs.oracle.com/javase/8/docs/api/javax/xml/parsers/DocumentBuilderFactory.html)
- [javax.xml.transform.TransformerFactory](http://docs.oracle.com/javase/8/docs/api/javax/xml/transform/TransformerFactory.html#newInstance--)
- [javax.xml.xpath.XPathFactory](http://docs.oracle.com/javase/8/docs/api/javax/xml/xpath/XPathFactory.html#newInstance--)

源码：https://github.com/HWYWL/design-patterns